{"version":3,"sources":["webpack://WebIDL2/webpack/universalModuleDefinition","webpack://WebIDL2/webpack/bootstrap","webpack://WebIDL2/./lib/error.js","webpack://WebIDL2/./lib/webidl2.js","webpack://WebIDL2/./lib/writer.js","webpack://WebIDL2/./lib/validator.js","webpack://WebIDL2/./index.js"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","error_error","source","position","current","message","type","sliceTokens","count","slice","Math","max","tokensToText","inputs","precedes","text","map","trivia","join","nextToken","length","line","precedingLine","splitted","split","lastLine","subsequentTokens","subsequentText","contextualMessage","repeat","partial","input","tokens","validationError","token","index","tokenRe","decimal","integer","identifier","string","whitespace","comment","other","stringTypes","argumentNameKeywords","nonRegexTerminals","concat","punctuations","WebIDLParseError","Error","[object Object]","super","parseByTokens","DECIMAL","INT","ID","STR","error","str","syntaxError","consume_position","probe","consume","candidates","unescape","startsWith","unconsume","list","parser","allowDangler","listName","first","separator","items","item","push","Definition","defineProperties","json","undefined","proto","descMap","getOwnPropertyDescriptors","entries","getPrototypeOf","primitive_type","num_type","prefix","base","postfix","Type","integer_type","float_type","const_value","const_data","negative","type_suffix","obj","nullable","extAttrs","generic","union","idlType","subtype","filter","GenericType","typeName","ret","open","return_type","type_with_extended_attributes","keyType","keyIdlType","valueType","close","UnionType","typ","or","parse","single_type","ExtendedAttributes","Argument","start_position","optional","variadic","default","Default","argument_list","Token","ExtendedAttributeParameters","assign","secondaryName","rhsType","ids","identifiers","hasRhs","SimpleExtendedAttribute","params","rhs","arguments","def","expression","Constant","termination","CallbackFunction","Attribute","special","noInherit","readonly","voidToken","OperationBody","Operation","regular","body","static_member","stringifier","IterableLike","secondTypeRequired","secondTypeAllowed","Inheritance","colon","Container","instance","inheritable","allowedMembers","inheritance","members","ea","mem","args","Interface","callback","Mixin","mixin","interface_","opts","Namespace","Dictionary","Field","required","Enum","values","EnumValue","Typedef","Includes","target","includes","definition","tok","res","defs","definitions","lastCharIndex","nextChar","charAt","result","test","attemptTokenMatch","noFlushTrivia","currentTrivia","pop","match","punctuation","re","lastIndex","exec","tokenise","noop","arg","templates","wrap","reference","extendedAttribute","extendedAttributeReference","write","ast","ts","strings","raw","unescaped","reference_token","name_token","type_body","it","firstToken","ref","extended_attributes","default_","argument","data","id","make_ext_at","eats","container","inh","iterate","iterable_like","parent","table","interface","interface mixin","namespace","operation","attribute","dictionary","field","const","typedef","enum","enum-value","v","iterable","legacyiterable","maplike","setlike","callback interface","eof","things","results","thing","dispatch","checkDuplicatedNames","unique","duplicates","dup","checkInterfaceMemberDuplication","interfaces","includesMap","Map","all","include","array","set","getIncludesMap","forEachInterface","opNames","Set","getOperations","op","partials","mixins","ext","additions","forEachExtension","addition","add","existings","has","validate","groupDefinitions","__webpack_exports__"],"mappings":"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","file":"webidl2.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WebIDL2\"] = factory();\n\telse\n\t\troot[\"WebIDL2\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\r\n * @param {string} text\r\n */\r\nfunction lastLine(text) {\r\n  const splitted = text.split(\"\\n\");\r\n  return splitted[splitted.length - 1];\r\n}\r\n\r\n/**\r\n * @param {string} message error message\r\n * @param {\"Syntax\" | \"Validation\"} type error type\r\n */\r\nfunction error(source, position, current, message, type) {\r\n  /**\r\n   * @param {number} count\r\n   */\r\n  function sliceTokens(count) {\r\n    return count > 0 ?\r\n      source.slice(position, position + count) :\r\n      source.slice(Math.max(position + count, 0), position);\r\n  }\r\n\r\n  function tokensToText(inputs, { precedes } = {}) {\r\n    const text = inputs.map(t => t.trivia + t.value).join(\"\");\r\n    const nextToken = source[position];\r\n    if (nextToken.type === \"eof\") {\r\n      return text;\r\n    }\r\n    if (precedes) {\r\n      return text + nextToken.trivia;\r\n    }\r\n    return text.slice(nextToken.trivia.length);\r\n  }\r\n\r\n  const maxTokens = 5; // arbitrary but works well enough\r\n  const line =\r\n    source[position].type !== \"eof\" ? source[position].line :\r\n    source.length > 1 ? source[position - 1].line :\r\n    1;\r\n\r\n  const precedingLine = lastLine(\r\n    tokensToText(sliceTokens(-maxTokens), { precedes: true })\r\n  );\r\n\r\n  const subsequentTokens = sliceTokens(maxTokens);\r\n  const subsequentText = tokensToText(subsequentTokens);\r\n  const sobsequentLine = subsequentText.split(\"\\n\")[0];\r\n\r\n  const spaced = \" \".repeat(precedingLine.length) + \"^ \" + message;\r\n  const contextualMessage = precedingLine + sobsequentLine + \"\\n\" + spaced;\r\n\r\n  const contextType = type === \"Syntax\" ? \"since\" : \"inside\";\r\n  const grammaticalContext = current ? `, ${contextType} \\`${current.partial ? \"partial \" : \"\"}${current.type} ${current.name}\\`` : \"\";\r\n  return {\r\n    message: `${type} error at line ${line}${grammaticalContext}:\\n${contextualMessage}`,\r\n    line,\r\n    input: subsequentText,\r\n    tokens: subsequentTokens\r\n  };\r\n}\r\n\r\n/**\r\n * @param {string} message error message\r\n */\r\nexport function syntaxError(source, position, current, message) {\r\n  return error(source, position, current, message, \"Syntax\");\r\n}\r\n\r\n/**\r\n * @param {string} message error message\r\n */\r\nexport function validationError(source, token, current, message) {\r\n  return error(source, token.index, current, message, \"Validation\").message;\r\n}\r\n","\"use strict\";\r\n\r\nimport { syntaxError } from \"./error.js\";\r\n\r\n// These regular expressions use the sticky flag so they will only match at\r\n// the current location (ie. the offset of lastIndex).\r\nconst tokenRe = {\r\n  // This expression uses a lookahead assertion to catch false matches\r\n  // against integers early.\r\n  \"decimal\": /-?(?=[0-9]*\\.|[0-9]+[eE])(([0-9]+\\.[0-9]*|[0-9]*\\.[0-9]+)([Ee][-+]?[0-9]+)?|[0-9]+[Ee][-+]?[0-9]+)/y,\r\n  \"integer\": /-?(0([Xx][0-9A-Fa-f]+|[0-7]*)|[1-9][0-9]*)/y,\r\n  \"identifier\": /[_-]?[A-Za-z][0-9A-Z_a-z-]*/y,\r\n  \"string\": /\"[^\"]*\"/y,\r\n  \"whitespace\": /[\\t\\n\\r ]+/y,\r\n  \"comment\": /((\\/(\\/.*|\\*([^*]|\\*[^/])*\\*\\/)[\\t\\n\\r ]*)+)/y,\r\n  \"other\": /[^\\t\\n\\r 0-9A-Za-z]/y\r\n};\r\n\r\nconst stringTypes = [\r\n  \"ByteString\",\r\n  \"DOMString\",\r\n  \"USVString\"\r\n];\r\n\r\nconst argumentNameKeywords = [\r\n  \"attribute\",\r\n  \"callback\",\r\n  \"const\",\r\n  \"deleter\",\r\n  \"dictionary\",\r\n  \"enum\",\r\n  \"getter\",\r\n  \"includes\",\r\n  \"inherit\",\r\n  \"interface\",\r\n  \"iterable\",\r\n  \"maplike\",\r\n  \"namespace\",\r\n  \"partial\",\r\n  \"required\",\r\n  \"setlike\",\r\n  \"setter\",\r\n  \"static\",\r\n  \"stringifier\",\r\n  \"typedef\",\r\n  \"unrestricted\"\r\n];\r\n\r\nconst nonRegexTerminals = [\r\n  \"-Infinity\",\r\n  \"FrozenArray\",\r\n  \"Infinity\",\r\n  \"NaN\",\r\n  \"Promise\",\r\n  \"boolean\",\r\n  \"byte\",\r\n  \"double\",\r\n  \"false\",\r\n  \"float\",\r\n  \"implements\",\r\n  \"legacyiterable\",\r\n  \"long\",\r\n  \"mixin\",\r\n  \"null\",\r\n  \"octet\",\r\n  \"optional\",\r\n  \"or\",\r\n  \"readonly\",\r\n  \"record\",\r\n  \"sequence\",\r\n  \"short\",\r\n  \"true\",\r\n  \"unsigned\",\r\n  \"void\"\r\n].concat(argumentNameKeywords, stringTypes);\r\n\r\nconst punctuations = [\r\n  \"(\",\r\n  \")\",\r\n  \",\",\r\n  \"...\",\r\n  \":\",\r\n  \";\",\r\n  \"<\",\r\n  \"=\",\r\n  \">\",\r\n  \"?\",\r\n  \"[\",\r\n  \"]\",\r\n  \"{\",\r\n  \"}\"\r\n];\r\n\r\nfunction tokenise(str) {\r\n  const tokens = [];\r\n  let lastCharIndex = 0;\r\n  let trivia = \"\";\r\n  let line = 1;\r\n  let index = 0;\r\n  while (lastCharIndex < str.length) {\r\n    const nextChar = str.charAt(lastCharIndex);\r\n    let result = -1;\r\n\r\n    if (/[\\t\\n\\r ]/.test(nextChar)) {\r\n      result = attemptTokenMatch(\"whitespace\", { noFlushTrivia: true });\r\n    } else if (nextChar === '/') {\r\n      result = attemptTokenMatch(\"comment\", { noFlushTrivia: true });\r\n    }\r\n\r\n    if (result !== -1) {\r\n      const currentTrivia = tokens.pop().value;\r\n      line += (currentTrivia.match(/\\n/g) || []).length;\r\n      trivia += currentTrivia;\r\n      index -= 1;\r\n    } else if (/[-0-9.A-Z_a-z]/.test(nextChar)) {\r\n      result = attemptTokenMatch(\"decimal\");\r\n      if (result === -1) {\r\n        result = attemptTokenMatch(\"integer\");\r\n      }\r\n      if (result === -1) {\r\n        result = attemptTokenMatch(\"identifier\");\r\n        const token = tokens[tokens.length - 1];\r\n        if (result !== -1 && nonRegexTerminals.includes(token.value)) {\r\n          token.type = token.value;\r\n        }\r\n      }\r\n    } else if (nextChar === '\"') {\r\n      result = attemptTokenMatch(\"string\");\r\n    }\r\n\r\n    for (const punctuation of punctuations) {\r\n      if (str.startsWith(punctuation, lastCharIndex)) {\r\n        tokens.push({ type: punctuation, value: punctuation, trivia, line, index });\r\n        trivia = \"\";\r\n        lastCharIndex += punctuation.length;\r\n        result = lastCharIndex;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // other as the last try\r\n    if (result === -1) {\r\n      result = attemptTokenMatch(\"other\");\r\n    }\r\n    if (result === -1) {\r\n      throw new Error(\"Token stream not progressing\");\r\n    }\r\n    lastCharIndex = result;\r\n    index += 1;\r\n  }\r\n\r\n  // remaining trivia as eof\r\n  tokens.push({\r\n    type: \"eof\",\r\n    value: \"\",\r\n    trivia\r\n  });\r\n\r\n  return tokens;\r\n\r\n  function attemptTokenMatch(type, { noFlushTrivia } = {}) {\r\n    const re = tokenRe[type];\r\n    re.lastIndex = lastCharIndex;\r\n    const result = re.exec(str);\r\n    if (result) {\r\n      tokens.push({ type, value: result[0], trivia, line, index });\r\n      if (!noFlushTrivia) {\r\n        trivia = \"\";\r\n      }\r\n      return re.lastIndex;\r\n    }\r\n    return -1;\r\n  }\r\n}\r\n\r\nclass WebIDLParseError extends Error {\r\n  constructor({ message, line, input, tokens }) {\r\n    super(message);\r\n    this.name = \"WebIDLParseError\"; // not to be mangled\r\n    this.line = line;\r\n    this.input = input;\r\n    this.tokens = tokens;\r\n  }\r\n}\r\n\r\nfunction parseByTokens(source) {\r\n  source = source.slice();\r\n  let current = null;\r\n\r\n  const DECIMAL = \"decimal\";\r\n  const INT = \"integer\";\r\n  const ID = \"identifier\";\r\n  const STR = \"string\";\r\n\r\n  function error(str) {\r\n    throw new WebIDLParseError(syntaxError(source, consume_position, current, str));\r\n  }\r\n\r\n  let consume_position = 0;\r\n\r\n  function probe(type) {\r\n    return source.length > consume_position && source[consume_position].type === type;\r\n  }\r\n\r\n  function consume(...candidates) {\r\n    // TODO: use const when Servo updates its JS engine\r\n    // eslint-disable-next-line prefer-const\r\n    for (let type of candidates) {\r\n      if (!probe(type)) continue;\r\n      const token = source[consume_position];\r\n      consume_position++;\r\n      return token;\r\n    }\r\n  }\r\n\r\n  function unescape(identifier) {\r\n    return identifier.startsWith('_') ? identifier.slice(1) : identifier;\r\n  }\r\n\r\n  function unconsume(position) {\r\n    consume_position = position;\r\n  }\r\n\r\n  /**\r\n   * Parses comma-separated list\r\n   * @param {object} args\r\n   * @param {Function} args.parser parser function for each item\r\n   * @param {boolean} [args.allowDangler] whether to allow dangling comma\r\n   * @param {string} [args.listName] the name to be shown on error messages\r\n   */\r\n  function list({ parser, allowDangler, listName = \"list\" }) {\r\n    const first = parser();\r\n    if (!first) {\r\n      return [];\r\n    }\r\n    first.tokens.separator = consume(\",\");\r\n    const items = [first];\r\n    while (first.tokens.separator) {\r\n      const item = parser();\r\n      if (!item) {\r\n        if (!allowDangler) {\r\n          error(`Trailing comma in ${listName}`);\r\n        }\r\n        break;\r\n      }\r\n      item.tokens.separator = consume(\",\");\r\n      items.push(item);\r\n      if (!item.tokens.separator) break;\r\n    }\r\n    return items;\r\n  }\r\n\r\n  class Definition {\r\n    constructor({ tokens }) {\r\n      Object.defineProperties(this, {\r\n        source: { value: source },\r\n        tokens: { value: tokens }\r\n      });\r\n    }\r\n\r\n    toJSON() {\r\n      const json = { type: undefined, name: undefined };\r\n      let proto = this;\r\n      while (proto !== Object.prototype) {\r\n        const descMap = Object.getOwnPropertyDescriptors(proto);\r\n        for (const [key, value] of Object.entries(descMap)) {\r\n          if (value.enumerable || value.get) {\r\n            json[key] = this[key];\r\n          }\r\n        }\r\n        proto = Object.getPrototypeOf(proto);\r\n      }\r\n      return json;\r\n    }\r\n  }\r\n\r\n  function integer_type() {\r\n    const prefix = consume(\"unsigned\");\r\n    const base = consume(\"short\", \"long\");\r\n    if (base) {\r\n      const postfix = consume(\"long\");\r\n      return new Type({ tokens: { prefix, base, postfix } });\r\n    }\r\n    if (prefix) error(\"Failed to parse integer type\");\r\n  }\r\n\r\n  function float_type() {\r\n    const prefix = consume(\"unrestricted\");\r\n    const base = consume(\"float\", \"double\");\r\n    if (base) {\r\n      return new Type({ tokens: { prefix, base } });\r\n    }\r\n    if (prefix) error(\"Failed to parse float type\");\r\n  }\r\n\r\n  function primitive_type() {\r\n    const num_type = integer_type() || float_type();\r\n    if (num_type) return num_type;\r\n    const base = consume(\"boolean\", \"byte\", \"octet\");\r\n    if (base) {\r\n      return new Type({ tokens: { base } });\r\n    }\r\n  }\r\n\r\n  function const_value() {\r\n    return consume(\"true\", \"false\", \"Infinity\", \"-Infinity\", \"NaN\", DECIMAL, INT);\r\n  }\r\n\r\n  function const_data(token) {\r\n    switch (token.type) {\r\n      case \"true\":\r\n      case \"false\":\r\n        return { type: \"boolean\", value: token.type === \"true\" };\r\n      case \"Infinity\":\r\n      case \"-Infinity\":\r\n        return { type: \"Infinity\", negative: token.type.startsWith(\"-\") };\r\n      case DECIMAL:\r\n      case INT:\r\n        return { type: \"number\", value: token.value };\r\n      case \"[\":\r\n        return { type: \"sequence\", value: [] };\r\n      case STR:\r\n        return { type: STR, value: token.value.slice(1, -1) };\r\n      default:\r\n        return { type: token.type };\r\n    }\r\n  }\r\n\r\n  function type_suffix(obj) {\r\n    const nullable = consume(\"?\");\r\n    if (nullable) {\r\n      obj.tokens.nullable = nullable;\r\n    }\r\n    if (probe(\"?\")) error(\"Can't nullable more than once\");\r\n  }\r\n\r\n  class Type extends Definition {\r\n    constructor({ tokens }) {\r\n      super({ tokens });\r\n      Object.defineProperty(this, \"subtype\", { value: [] });\r\n      this.extAttrs = null;\r\n    }\r\n\r\n    get generic() {\r\n      return \"\";\r\n    }\r\n    get nullable() {\r\n      return !!this.tokens.nullable;\r\n    }\r\n    get union() {\r\n      return false;\r\n    }\r\n    get idlType() {\r\n      if (this.subtype.length) {\r\n        return this.subtype;\r\n      }\r\n      // Adding prefixes/postfixes for \"unrestricted float\", etc.\r\n      const name = [\r\n        this.tokens.prefix,\r\n        this.tokens.base,\r\n        this.tokens.postfix\r\n      ].filter(t => t).map(t => t.value).join(\" \");\r\n      return unescape(name);\r\n    }\r\n  }\r\n\r\n  class GenericType extends Type {\r\n    static parse(typeName) {\r\n      const base = consume(\"FrozenArray\", \"Promise\", \"sequence\", \"record\");\r\n      if (!base) {\r\n        return;\r\n      }\r\n      const ret = new GenericType({ tokens: { base } });\r\n      ret.tokens.open = consume(\"<\") || error(`No opening bracket after ${base.type}`);\r\n      switch (base.type) {\r\n        case \"Promise\": {\r\n          if (probe(\"[\")) error(\"Promise type cannot have extended attribute\");\r\n          const subtype = return_type(typeName) || error(\"Missing Promise subtype\");\r\n          ret.subtype.push(subtype);\r\n          break;\r\n        }\r\n        case \"sequence\":\r\n        case \"FrozenArray\": {\r\n          const subtype = type_with_extended_attributes(typeName) || error(`Missing ${base.type} subtype`);\r\n          ret.subtype.push(subtype);\r\n          break;\r\n        }\r\n        case \"record\": {\r\n          if (probe(\"[\")) error(\"Record key cannot have extended attribute\");\r\n          const keyType = consume(...stringTypes) || error(`Record key must be one of: ${stringTypes.join(\", \")}`);\r\n          const keyIdlType = new Type({ tokens: { base: keyType }});\r\n          keyIdlType.tokens.separator = consume(\",\") || error(\"Missing comma after record key type\");\r\n          keyIdlType.type = typeName;\r\n          const valueType = type_with_extended_attributes(typeName) || error(\"Error parsing generic type record\");\r\n          ret.subtype.push(keyIdlType, valueType);\r\n          break;\r\n        }\r\n      }\r\n      if (!ret.idlType) error(`Error parsing generic type ${base.type}`);\r\n      ret.tokens.close = consume(\">\") || error(`Missing closing bracket after ${base.type}`);\r\n      return ret;\r\n    }\r\n\r\n    get generic() {\r\n      return this.tokens.base.value;\r\n    }\r\n  }\r\n\r\n  function single_type(typeName) {\r\n    let ret = GenericType.parse(typeName) || primitive_type();\r\n    if (!ret) {\r\n      const base = consume(ID, ...stringTypes);\r\n      if (!base) {\r\n        return;\r\n      }\r\n      ret = new Type({ tokens: { base } });\r\n      if (probe(\"<\")) error(`Unsupported generic type ${base.value}`);\r\n    }\r\n    if (ret.generic === \"Promise\" && probe(\"?\")) {\r\n      error(\"Promise type cannot be nullable\");\r\n    }\r\n    ret.type = typeName || null;\r\n    type_suffix(ret);\r\n    if (ret.nullable && ret.idlType === \"any\") error(\"Type `any` cannot be made nullable\");\r\n    return ret;\r\n  }\r\n\r\n  class UnionType extends Type {\r\n    static parse(type) {\r\n      const tokens = {};\r\n      tokens.open = consume(\"(\");\r\n      if (!tokens.open) return;\r\n      const ret = new UnionType({ tokens });\r\n      ret.type = type || null;\r\n      while (true) {\r\n        const typ = type_with_extended_attributes() || error(\"No type after open parenthesis or 'or' in union type\");\r\n        if (typ.idlType === \"any\") error(\"Type `any` cannot be included in a union type\");\r\n        ret.subtype.push(typ);\r\n        const or = consume(\"or\");\r\n        if (or) {\r\n          typ.tokens.separator = or;\r\n        }\r\n        else break;\r\n      }\r\n      if (ret.idlType.length < 2) {\r\n        error(\"At least two types are expected in a union type but found less\");\r\n      }\r\n      tokens.close = consume(\")\") || error(\"Unterminated union type\");\r\n      type_suffix(ret);\r\n      return ret;\r\n    }\r\n\r\n    get union() {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  function type(typeName) {\r\n    return single_type(typeName) || UnionType.parse(typeName);\r\n  }\r\n\r\n  function type_with_extended_attributes(typeName) {\r\n    const extAttrs = ExtendedAttributes.parse();\r\n    const ret = type(typeName);\r\n    if (ret) ret.extAttrs = extAttrs;\r\n    return ret;\r\n  }\r\n\r\n  class Argument extends Definition {\r\n    static parse() {\r\n      const start_position = consume_position;\r\n      const tokens = {};\r\n      const ret = new Argument({ tokens });\r\n      tokens.optional = consume(\"optional\");\r\n      ret.idlType = type_with_extended_attributes(\"argument-type\");\r\n      if (!ret.idlType) {\r\n        return unconsume(start_position);\r\n      }\r\n      if (!tokens.optional) {\r\n        tokens.variadic = consume(\"...\");\r\n      }\r\n      tokens.name = consume(ID, ...argumentNameKeywords);\r\n      if (!tokens.name) {\r\n        return unconsume(start_position);\r\n      }\r\n      ret.default = tokens.optional ? Default.parse() : null;\r\n      return ret;\r\n    }\r\n\r\n    get optional() {\r\n      return !!this.tokens.optional;\r\n    }\r\n    get variadic() {\r\n      return !!this.tokens.variadic;\r\n    }\r\n    get name() {\r\n      return unescape(this.tokens.name.value);\r\n    }\r\n  }\r\n\r\n  function argument_list() {\r\n    return list({ parser: Argument.parse, listName: \"arguments list\" });\r\n  }\r\n\r\n  class Token extends Definition {\r\n    /**\r\n     * @param {string} type\r\n     */\r\n    static parser(type) {\r\n      return () => {\r\n        const value = consume(type);\r\n        if (value) {\r\n          return new Token({ tokens: { value } });\r\n        }\r\n      };\r\n    }\r\n\r\n    get value() {\r\n      return this.tokens.value.value;\r\n    }\r\n  }\r\n\r\n  function identifiers() {\r\n    const ids = list({ parser: Token.parser(ID), listName: \"identifier list\" });\r\n    if (!ids.length) {\r\n      error(\"Expected identifiers but none found\");\r\n    }\r\n    return ids;\r\n  }\r\n\r\n  class ExtendedAttributeParameters extends Definition {\r\n    static parse() {\r\n      const tokens = { assign: consume(\"=\") };\r\n      const ret = new ExtendedAttributeParameters({ tokens });\r\n      if (tokens.assign) {\r\n        tokens.secondaryName = consume(ID, DECIMAL, INT, STR);\r\n      }\r\n      tokens.open = consume(\"(\");\r\n      if (tokens.open) {\r\n        ret.list = ret.rhsType === \"identifier-list\" ?\r\n          // [Exposed=(Window,Worker)]\r\n          identifiers() :\r\n          // [NamedConstructor=Audio(DOMString src)] or [Constructor(DOMString str)]\r\n          argument_list();\r\n        tokens.close = consume(\")\") || error(\"Unexpected token in extended attribute argument list\");\r\n      } else if (ret.hasRhs && !tokens.secondaryName) {\r\n        error(\"No right hand side to extended attribute assignment\");\r\n      }\r\n      return ret;\r\n    }\r\n\r\n    get rhsType() {\r\n      return !this.tokens.assign ? null :\r\n        !this.tokens.secondaryName ? \"identifier-list\" :\r\n        this.tokens.secondaryName.type;\r\n    }\r\n  }\r\n\r\n  class SimpleExtendedAttribute extends Definition {\r\n    static parse() {\r\n      const name = consume(ID);\r\n      if (name) {\r\n        return new SimpleExtendedAttribute({\r\n          tokens: { name },\r\n          params: ExtendedAttributeParameters.parse()\r\n        });\r\n      }\r\n    }\r\n\r\n    constructor({ tokens, params }) {\r\n      super({ tokens });\r\n      Object.defineProperty(this, \"params\", { value: params });\r\n    }\r\n\r\n    get type() {\r\n      return \"extended-attribute\";\r\n    }\r\n    get name() {\r\n      return this.tokens.name.value;\r\n    }\r\n    get rhs() {\r\n      const { rhsType: type, tokens, list } = this.params;\r\n      if (!type) {\r\n        return null;\r\n      }\r\n      const value = type === \"identifier-list\" ? list : tokens.secondaryName.value;\r\n      return { type, value };\r\n    }\r\n    get arguments() {\r\n      const { rhsType, list } = this.params;\r\n      if (!list || rhsType === \"identifier-list\") {\r\n        return [];\r\n      }\r\n      return list;\r\n    }\r\n  }\r\n\r\n  // Note: we parse something simpler than the official syntax. It's all that ever\r\n  // seems to be used\r\n  class ExtendedAttributes extends Definition {\r\n    static parse() {\r\n      const tokens = {};\r\n      tokens.open = consume(\"[\");\r\n      if (!tokens.open) return null;\r\n      const ret = new ExtendedAttributes({ tokens });\r\n      ret.items = list({\r\n        parser: SimpleExtendedAttribute.parse,\r\n        listName: \"extended attribute\"\r\n      });\r\n      tokens.close = consume(\"]\") || error(\"Unexpected form of extended attribute\");\r\n      if (!ret.items.length) {\r\n        error(\"Found an empty extended attribute\");\r\n      }\r\n      return ret;\r\n    }\r\n  }\r\n\r\n  class Default extends Definition {\r\n    static parse() {\r\n      const assign = consume(\"=\");\r\n      if (!assign) {\r\n        return null;\r\n      }\r\n      const def = const_value() || consume(STR, \"null\", \"[\") || error(\"No value for default\");\r\n      const expression = [def];\r\n      if (def.type === \"[\") {\r\n        const close = consume(\"]\") || error(\"Default sequence value must be empty\");\r\n        expression.push(close);\r\n      }\r\n      return new Default({ tokens: { assign }, expression });\r\n    }\r\n\r\n    constructor({ tokens, expression }) {\r\n      super({ tokens });\r\n      Object.defineProperty(this, \"expression\", { value: expression });\r\n    }\r\n\r\n    get type() {\r\n      return const_data(this.expression[0]).type;\r\n    }\r\n    get value() {\r\n      return const_data(this.expression[0]).value;\r\n    }\r\n    get negative() {\r\n      return const_data(this.expression[0]).negative;\r\n    }\r\n  }\r\n\r\n  class Constant extends Definition {\r\n    static parse() {\r\n      const tokens = {};\r\n      tokens.base = consume(\"const\");\r\n      if (!tokens.base) {\r\n        return;\r\n      }\r\n      let idlType = primitive_type();\r\n      if (!idlType) {\r\n        const base = consume(ID) || error(\"No type for const\");\r\n        idlType = new Type({ tokens: { base } });\r\n      }\r\n      if (probe(\"?\")) {\r\n        error(\"Unexpected nullable constant type\");\r\n      }\r\n      idlType.type = \"const-type\";\r\n      tokens.name = consume(ID) || error(\"No name for const\");\r\n      tokens.assign = consume(\"=\") || error(\"No value assignment for const\");\r\n      tokens.value = const_value() || error(\"No value for const\");\r\n      tokens.termination = consume(\";\") || error(\"Unterminated const\");\r\n      const ret = new Constant({ tokens });\r\n      ret.idlType = idlType;\r\n      return ret;\r\n    }\r\n\r\n    get type() {\r\n      return \"const\";\r\n    }\r\n    get name() {\r\n      return unescape(this.tokens.name.value);\r\n    }\r\n    get value() {\r\n      return const_data(this.tokens.value);\r\n    }\r\n  }\r\n\r\n  class CallbackFunction extends Definition {\r\n    static parse(base) {\r\n      const tokens = { base };\r\n      const ret = new CallbackFunction({ tokens });\r\n      tokens.name = consume(ID) || error(\"No name for callback\");\r\n      current = ret;\r\n      tokens.assign = consume(\"=\") || error(\"No assignment in callback\");\r\n      ret.idlType = return_type() || error(\"Missing return type\");\r\n      tokens.open = consume(\"(\") || error(\"No arguments in callback\");\r\n      ret.arguments = argument_list();\r\n      tokens.close = consume(\")\") || error(\"Unterminated callback\");\r\n      tokens.termination = consume(\";\") || error(\"Unterminated callback\");\r\n      return ret;\r\n    }\r\n\r\n    get type() {\r\n      return \"callback\";\r\n    }\r\n    get name() {\r\n      return unescape(this.tokens.name.value);\r\n    }\r\n  }\r\n\r\n  function callback() {\r\n    const callback = consume(\"callback\");\r\n    if (!callback) return;\r\n    const tok = consume(\"interface\");\r\n    if (tok) {\r\n      return Interface.parse(tok, { callback });\r\n    }\r\n    return CallbackFunction.parse(callback);\r\n  }\r\n\r\n  class Attribute extends Definition {\r\n    static parse({ special, noInherit = false, readonly = false } = {}) {\r\n      const start_position = consume_position;\r\n      const tokens = { special };\r\n      const ret = new Attribute({ tokens });\r\n      if (!special && !noInherit) {\r\n        tokens.special = consume(\"inherit\");\r\n      }\r\n      tokens.readonly = consume(\"readonly\");\r\n      if (readonly && !tokens.readonly && probe(\"attribute\")) {\r\n        error(\"Attributes must be readonly in this context\");\r\n      }\r\n      tokens.base = consume(\"attribute\");\r\n      if (!tokens.base) {\r\n        unconsume(start_position);\r\n        return;\r\n      }\r\n      ret.idlType = type_with_extended_attributes(\"attribute-type\") || error(\"No type in attribute\");\r\n      switch (ret.idlType.generic) {\r\n        case \"sequence\":\r\n        case \"record\": error(`Attributes cannot accept ${ret.idlType.generic} types`);\r\n      }\r\n      tokens.name = consume(ID, \"required\") || error(\"No name in attribute\");\r\n      tokens.termination = consume(\";\") || error(\"Unterminated attribute\");\r\n      return ret;\r\n    }\r\n\r\n    get type() {\r\n      return \"attribute\";\r\n    }\r\n    get special() {\r\n      if (!this.tokens.special) {\r\n        return \"\";\r\n      }\r\n      return this.tokens.special.value;\r\n    }\r\n    get readonly() {\r\n      return !!this.tokens.readonly;\r\n    }\r\n    get name() {\r\n      return unescape(this.tokens.name.value);\r\n    }\r\n  }\r\n\r\n  function return_type(typeName) {\r\n    const typ = type(typeName || \"return-type\");\r\n    if (typ) {\r\n      return typ;\r\n    }\r\n    const voidToken = consume(\"void\");\r\n    if (voidToken) {\r\n      const ret = new Type({ tokens: { base: voidToken } });\r\n      ret.type = \"return-type\";\r\n      return ret;\r\n    }\r\n  }\r\n\r\n  class OperationBody extends Definition {\r\n    static parse() {\r\n      const tokens = {};\r\n      const ret = new OperationBody({ tokens });\r\n      ret.idlType = return_type() || error(\"Missing return type\");\r\n      tokens.name = consume(ID);\r\n      tokens.open = consume(\"(\") || error(\"Invalid operation\");\r\n      ret.arguments = argument_list();\r\n      tokens.close = consume(\")\") || error(\"Unterminated operation\");\r\n      return ret;\r\n    }\r\n\r\n    get name() {\r\n      const { name } = this.tokens;\r\n      if (!name) {\r\n        return \"\";\r\n      }\r\n      return unescape(name.value);\r\n    }\r\n  }\r\n\r\n  class Operation extends Definition {\r\n    static parse({ special, regular } = {}) {\r\n      const tokens = { special };\r\n      const ret = new Operation({ tokens });\r\n      if (special && special.value === \"stringifier\") {\r\n        tokens.termination = consume(\";\");\r\n        if (tokens.termination) {\r\n          ret.body = null;\r\n          return ret;\r\n        }\r\n      }\r\n      if (!special && !regular) {\r\n        tokens.special = consume(\"getter\", \"setter\", \"deleter\");\r\n      }\r\n      ret.body = OperationBody.parse();\r\n      tokens.termination = consume(\";\") || error(\"Unterminated attribute\");\r\n      return ret;\r\n    }\r\n\r\n    get type() {\r\n      return \"operation\";\r\n    }\r\n    get name() {\r\n      return (this.body && this.body.name) || \"\";\r\n    }\r\n    get special() {\r\n      if (!this.tokens.special) {\r\n        return \"\";\r\n      }\r\n      return this.tokens.special.value;\r\n    }\r\n  }\r\n\r\n  function static_member() {\r\n    const special = consume(\"static\");\r\n    if (!special) return;\r\n    const member = Attribute.parse({ special }) ||\r\n      Operation.parse({ special }) ||\r\n      error(\"No body in static member\");\r\n    return member;\r\n  }\r\n\r\n  function stringifier() {\r\n    const special = consume(\"stringifier\");\r\n    if (!special) return;\r\n    const member = Attribute.parse({ special }) ||\r\n      Operation.parse({ special }) ||\r\n      error(\"Unterminated stringifier\");\r\n    return member;\r\n  }\r\n\r\n  class IterableLike extends Definition {\r\n    static parse() {\r\n      const start_position = consume_position;\r\n      const tokens = {};\r\n      const ret = new IterableLike({ tokens });\r\n      tokens.readonly = consume(\"readonly\");\r\n      tokens.base = tokens.readonly ?\r\n        consume(\"maplike\", \"setlike\") :\r\n        consume(\"iterable\", \"maplike\", \"setlike\");\r\n      if (!tokens.base) {\r\n        unconsume(start_position);\r\n        return;\r\n      }\r\n\r\n      const { type } = ret;\r\n      const secondTypeRequired = type === \"maplike\";\r\n      const secondTypeAllowed = secondTypeRequired || type === \"iterable\";\r\n\r\n      tokens.open = consume(\"<\") || error(`Error parsing ${type} declaration`);\r\n      const first = type_with_extended_attributes() || error(`Error parsing ${type} declaration`);\r\n      ret.idlType = [first];\r\n      if (secondTypeAllowed) {\r\n        first.tokens.separator = consume(\",\");\r\n        if (first.tokens.separator) {\r\n          ret.idlType.push(type_with_extended_attributes());\r\n        }\r\n        else if (secondTypeRequired)\r\n          error(`Missing second type argument in ${type} declaration`);\r\n      }\r\n      tokens.close = consume(\">\") || error(`Unterminated ${type} declaration`);\r\n      tokens.termination = consume(\";\") || error(`Missing semicolon after ${type} declaration`);\r\n\r\n      return ret;\r\n    }\r\n\r\n    get type() {\r\n      return this.tokens.base.value;\r\n    }\r\n    get readonly() {\r\n      return !!this.tokens.readonly;\r\n    }\r\n  }\r\n\r\n  class Inheritance extends Definition {\r\n    static parse() {\r\n      const colon = consume(\":\");\r\n      if (!colon) {\r\n        return;\r\n      }\r\n      const name = consume(ID) || error(\"No type in inheritance\");\r\n      return new Inheritance({ tokens: { colon, name } });\r\n    }\r\n\r\n    get name() {\r\n      return unescape(this.tokens.name.value);\r\n    }\r\n  }\r\n\r\n  class Container extends Definition {\r\n    static parse(instance, { type, inheritable, allowedMembers }) {\r\n      const { tokens } = instance;\r\n      tokens.name = consume(ID) || error(\"No name for interface\");\r\n      current = instance;\r\n      if (inheritable) {\r\n        instance.inheritance = Inheritance.parse() || null;\r\n      }\r\n      tokens.open = consume(\"{\") || error(`Bodyless ${type}`);\r\n      instance.members = [];\r\n      while (true) {\r\n        tokens.close = consume(\"}\");\r\n        if (tokens.close) {\r\n          tokens.termination = consume(\";\") || error(`Missing semicolon after ${type}`);\r\n          return instance;\r\n        }\r\n        const ea = ExtendedAttributes.parse();\r\n        let mem;\r\n        for (const [parser, ...args] of allowedMembers) {\r\n          mem = parser(...args);\r\n          if (mem) {\r\n            break;\r\n          }\r\n        }\r\n        if (!mem) {\r\n          error(\"Unknown member\");\r\n        }\r\n        mem.extAttrs = ea;\r\n        instance.members.push(mem);\r\n      }\r\n    }\r\n\r\n    get partial() {\r\n      return !!this.tokens.partial;\r\n    }\r\n    get name() {\r\n      return unescape(this.tokens.name.value);\r\n    }\r\n  }\r\n\r\n  class Interface extends Container {\r\n    static parse(base, { callback = null, partial = null } = {}) {\r\n      const tokens = { callback, partial, base };\r\n      return Container.parse(new Interface({ tokens }), {\r\n        type: \"interface\",\r\n        inheritable: !partial,\r\n        allowedMembers: [\r\n          [Constant.parse],\r\n          [static_member],\r\n          [stringifier],\r\n          [IterableLike.parse],\r\n          [Attribute.parse],\r\n          [Operation.parse]\r\n        ]\r\n      });\r\n    }\r\n\r\n    get type() {\r\n      if (this.tokens.callback) {\r\n        return \"callback interface\";\r\n      }\r\n      return \"interface\";\r\n    }\r\n  }\r\n\r\n  class Mixin extends Container {\r\n    static parse(base, { partial } = {}) {\r\n      const tokens = { partial, base };\r\n      tokens.mixin = consume(\"mixin\");\r\n      if (!tokens.mixin) {\r\n        return;\r\n      }\r\n      return Container.parse(new Mixin({ tokens }), {\r\n        type: \"interface mixin\",\r\n        allowedMembers: [\r\n          [Constant.parse],\r\n          [stringifier],\r\n          [Attribute.parse, { noInherit: true }],\r\n          [Operation.parse, { regular: true }]\r\n        ]\r\n      });\r\n    }\r\n\r\n    get type() {\r\n      return \"interface mixin\";\r\n    }\r\n  }\r\n\r\n  function interface_(opts) {\r\n    const base = consume(\"interface\");\r\n    if (!base) return;\r\n    const ret = Mixin.parse(base, opts) ||\r\n      Interface.parse(base, opts) ||\r\n      error(\"Interface has no proper body\");\r\n    return ret;\r\n  }\r\n\r\n  class Namespace extends Container {\r\n    static parse({ partial } = {}) {\r\n      const tokens = { partial };\r\n      tokens.base = consume(\"namespace\");\r\n      if (!tokens.base) {\r\n        return;\r\n      }\r\n      return Container.parse(new Namespace({ tokens }), {\r\n        type: \"namespace\",\r\n        allowedMembers: [\r\n          [Attribute.parse, { noInherit: true, readonly: true }],\r\n          [Operation.parse, { regular: true }]\r\n        ]\r\n      });\r\n    }\r\n\r\n    get type() {\r\n      return \"namespace\";\r\n    }\r\n  }\r\n\r\n  function partial() {\r\n    const partial = consume(\"partial\");\r\n    if (!partial) return;\r\n    return Dictionary.parse({ partial }) ||\r\n      interface_({ partial }) ||\r\n      Namespace.parse({ partial }) ||\r\n      error(\"Partial doesn't apply to anything\");\r\n  }\r\n\r\n  class Dictionary extends Container {\r\n    static parse({ partial } = {}) {\r\n      const tokens = { partial };\r\n      tokens.base = consume(\"dictionary\");\r\n      if (!tokens.base) {\r\n        return;\r\n      }\r\n      return Container.parse(new Dictionary({ tokens }), {\r\n        type: \"dictionary\",\r\n        inheritable: !partial,\r\n        allowedMembers: [\r\n          [Field.parse],\r\n        ]\r\n      });\r\n    }\r\n\r\n    get type() {\r\n      return \"dictionary\";\r\n    }\r\n  }\r\n\r\n  class Field extends Definition {\r\n    static parse() {\r\n      const tokens = {};\r\n      const ret = new Field({ tokens });\r\n      ret.extAttrs = ExtendedAttributes.parse();\r\n      tokens.required = consume(\"required\");\r\n      ret.idlType = type_with_extended_attributes(\"dictionary-type\") || error(\"No type for dictionary member\");\r\n      tokens.name = consume(ID) || error(\"No name for dictionary member\");\r\n      ret.default = Default.parse();\r\n      if (tokens.required && ret.default) error(\"Required member must not have a default\");\r\n      tokens.termination = consume(\";\") || error(\"Unterminated dictionary member\");\r\n      return ret;\r\n    }\r\n\r\n    get type() {\r\n      return \"field\";\r\n    }\r\n    get name() {\r\n      return unescape(this.tokens.name.value);\r\n    }\r\n    get required() {\r\n      return !!this.tokens.required;\r\n    }\r\n  }\r\n\r\n  class Enum extends Definition {\r\n    static parse() {\r\n      const tokens = {};\r\n      tokens.base = consume(\"enum\");\r\n      if (!tokens.base) {\r\n        return;\r\n      }\r\n      tokens.name = consume(ID) || error(\"No name for enum\");\r\n      current = new Enum({ tokens });\r\n      tokens.open = consume(\"{\") || error(\"Bodyless enum\");\r\n      current.values = list({\r\n        parser: EnumValue.parse,\r\n        allowDangler: true,\r\n        listName: \"enumeration\"\r\n      });\r\n      if (probe(STR)) {\r\n        error(\"No comma between enum values\");\r\n      }\r\n      tokens.close = consume(\"}\") || error(\"Unexpected value in enum\");\r\n      if (!current.values.length) {\r\n        error(\"No value in enum\");\r\n      }\r\n      tokens.termination = consume(\";\") || error(\"No semicolon after enum\");\r\n      return current;\r\n    }\r\n\r\n    get type() {\r\n      return \"enum\";\r\n    }\r\n    get name() {\r\n      return unescape(this.tokens.name.value);\r\n    }\r\n  }\r\n\r\n  class EnumValue extends Token {\r\n    static parse() {\r\n      const value = consume(STR);\r\n      if (value) {\r\n        return new EnumValue({ tokens: { value } });\r\n      }\r\n    }\r\n\r\n    get type() {\r\n      return \"enum-value\";\r\n    }\r\n    get value() {\r\n      return super.value.slice(1, -1);\r\n    }\r\n  }\r\n\r\n  class Typedef extends Definition {\r\n    static parse() {\r\n      const tokens = {};\r\n      const ret = new Typedef({ tokens });\r\n      tokens.base = consume(\"typedef\");\r\n      if (!tokens.base) {\r\n        return;\r\n      }\r\n      ret.idlType = type_with_extended_attributes(\"typedef-type\") || error(\"No type in typedef\");\r\n      tokens.name = consume(ID) || error(\"No name in typedef\");\r\n      current = ret;\r\n      tokens.termination = consume(\";\") || error(\"Unterminated typedef\");\r\n      return ret;\r\n    }\r\n\r\n    get type() {\r\n      return \"typedef\";\r\n    }\r\n    get name() {\r\n      return unescape(this.tokens.name.value);\r\n    }\r\n  }\r\n\r\n  class Includes extends Definition {\r\n    static parse() {\r\n      const target = consume(ID);\r\n      if (!target) {\r\n        return;\r\n      }\r\n      const tokens = { target };\r\n      tokens.includes = consume(\"includes\");\r\n      if (!tokens.includes) {\r\n        unconsume(target.index);\r\n        return;\r\n      }\r\n      tokens.mixin = consume(ID) || error(\"Incomplete includes statement\");\r\n      tokens.termination = consume(\";\") || error(\"No terminating ; for includes statement\");\r\n      return new Includes({ tokens });\r\n    }\r\n\r\n    get type() {\r\n      return \"includes\";\r\n    }\r\n    get target() {\r\n      return unescape(this.tokens.target.value);\r\n    }\r\n    get includes() {\r\n      return unescape(this.tokens.mixin.value);\r\n    }\r\n  }\r\n\r\n  function definition() {\r\n    return callback() ||\r\n      interface_() ||\r\n      partial() ||\r\n      Dictionary.parse() ||\r\n      Enum.parse() ||\r\n      Typedef.parse() ||\r\n      Includes.parse() ||\r\n      Namespace.parse();\r\n  }\r\n\r\n  function definitions() {\r\n    if (!source.length) return [];\r\n    const defs = [];\r\n    while (true) {\r\n      const ea = ExtendedAttributes.parse();\r\n      const def = definition();\r\n      if (!def) {\r\n        if (ea) error(\"Stray extended attributes\");\r\n        break;\r\n      }\r\n      def.extAttrs = ea;\r\n      defs.push(def);\r\n    }\r\n    defs.push(consume(\"eof\"));\r\n    return defs;\r\n  }\r\n  const res = definitions();\r\n  if (consume_position < source.length) error(\"Unrecognised tokens\");\r\n  return res;\r\n}\r\n\r\nexport function parse(str) {\r\n  const tokens = tokenise(str);\r\n  return parseByTokens(tokens);\r\n}\r\n","\"use strict\";\n\nfunction noop(arg) {\n  return arg;\n}\n\nconst templates = {\n  wrap: items => items.join(\"\"),\n  trivia: noop,\n  name: noop,\n  reference: noop,\n  type: noop,\n  inheritance: noop,\n  definition: noop,\n  extendedAttribute: noop,\n  extendedAttributeReference: noop\n};\n\nexport function write(ast, { templates: ts = templates } = {}) {\n  ts = Object.assign({}, templates, ts);\n\n  /**\n   * @param {string[]} strings\n   * @param  {...any} args\n   */\n  function wrap(strings, ...args) {\n    return ts.wrap([].concat(...strings.map((s, i) => [s, args[i] || \"\"])));\n  }\n\n  function reference(raw, unescaped) {\n    return ts.reference(raw, unescaped || raw);\n  }\n\n  function token(t, value) {\n    return t ? wrap`${ts.trivia(t.trivia)}${value || t.value}` : \"\";\n  }\n\n  function reference_token(t, unescaped) {\n    return t ? wrap`${ts.trivia(t.trivia)}${reference(t.value, unescaped)}` : \"\";\n  }\n\n  function name_token(t, arg) {\n    return t ? wrap`${ts.trivia(t.trivia)}${ts.name(t.value, arg)}` : \"\";\n  }\n\n  function type_body(it) {\n    if (it.union || it.generic) {\n      return ts.wrap([\n        reference_token(it.tokens.base),\n        token(it.tokens.open),\n        ...it.subtype.map(type),\n        token(it.tokens.close)\n      ]);\n    }\n    const firstToken = it.tokens.prefix || it.tokens.base;\n    const prefix = it.tokens.prefix ? [\n      it.tokens.prefix.value,\n      ts.trivia(it.tokens.base.trivia)\n    ] : [];\n    const ref = reference(ts.wrap([\n      ...prefix,\n      it.tokens.base.value,\n      token(it.tokens.postfix)\n    ]), it.idlType);\n    return ts.wrap([ts.trivia(firstToken.trivia), ref]);\n  }\n  function type(it) {\n    return ts.wrap([\n      extended_attributes(it.extAttrs),\n      type_body(it),\n      token(it.tokens.nullable),\n      token(it.tokens.separator)\n    ]);\n  }\n  function default_(def) {\n    if (!def) {\n      return \"\";\n    }\n    return ts.wrap([\n      token(def.tokens.assign),\n      ...def.expression.map(t => token(t))\n    ]);\n  }\n  function argument(arg) {\n    return ts.wrap([\n      extended_attributes(arg.extAttrs),\n      token(arg.tokens.optional),\n      ts.type(type(arg.idlType)),\n      token(arg.tokens.variadic),\n      name_token(arg.tokens.name, { data: arg }),\n      default_(arg.default),\n      token(arg.tokens.separator)\n    ]);\n  }\n  function identifier(id) {\n    return ts.wrap([\n      reference_token(id.tokens.value),\n      token(id.tokens.separator)\n    ]);\n  }\n  function make_ext_at(it) {\n    const { rhsType } = it.params;\n    return ts.wrap([\n      ts.trivia(it.tokens.name.trivia),\n      ts.extendedAttribute(ts.wrap([\n        ts.extendedAttributeReference(it.name),\n        token(it.params.tokens.assign),\n        reference_token(it.params.tokens.secondaryName),\n        token(it.params.tokens.open),\n        ...!it.params.list ? [] :\n          it.params.list.map(\n            rhsType === \"identifier-list\" ? identifier : argument\n          ),\n        token(it.params.tokens.close)\n      ])),\n      token(it.tokens.separator)\n    ]);\n  }\n  function extended_attributes(eats) {\n    if (!eats) return \"\";\n    return ts.wrap([\n      token(eats.tokens.open),\n      ...eats.items.map(make_ext_at),\n      token(eats.tokens.close)\n    ]);\n  }\n\n  function operation(it, parent) {\n    const body = it.body ? [\n      ts.type(type(it.body.idlType)),\n      name_token(it.body.tokens.name, { data: it, parent }),\n      token(it.body.tokens.open),\n      ts.wrap(it.body.arguments.map(argument)),\n      token(it.body.tokens.close),\n    ] : [];\n    return ts.definition(ts.wrap([\n      extended_attributes(it.extAttrs),\n      token(it.tokens.special),\n      ...body,\n      token(it.tokens.termination)\n    ]), { data: it, parent });\n  }\n\n  function attribute(it, parent) {\n    return ts.definition(ts.wrap([\n      extended_attributes(it.extAttrs),\n      token(it.tokens.special),\n      token(it.tokens.readonly),\n      token(it.tokens.base),\n      ts.type(type(it.idlType)),\n      name_token(it.tokens.name, { data: it, parent }),\n      token(it.tokens.termination)\n    ]), { data: it, parent });\n  }\n\n  function inheritance(inh) {\n    if (!inh) {\n      return \"\";\n    }\n    return ts.wrap([\n      token(inh.tokens.colon),\n      ts.trivia(inh.tokens.name.trivia),\n      ts.inheritance(reference(inh.tokens.name.value, inh.name))\n    ]);\n  }\n\n  function container(it) {\n    return ts.definition(ts.wrap([\n      extended_attributes(it.extAttrs),\n      token(it.tokens.callback),\n      token(it.tokens.partial),\n      token(it.tokens.base),\n      token(it.tokens.mixin),\n      name_token(it.tokens.name, { data: it }),\n      inheritance(it.inheritance),\n      token(it.tokens.open),\n      iterate(it.members, it),\n      token(it.tokens.close),\n      token(it.tokens.termination)\n    ]), { data: it });\n  }\n\n  function field(it, parent) {\n    return ts.definition(ts.wrap([\n      extended_attributes(it.extAttrs),\n      token(it.tokens.required),\n      ts.type(type(it.idlType)),\n      name_token(it.tokens.name, { data: it, parent }),\n      default_(it.default),\n      token(it.tokens.termination)\n    ]), { data: it, parent });\n  }\n  function const_(it, parent) {\n    return ts.definition(ts.wrap([\n      extended_attributes(it.extAttrs),\n      token(it.tokens.base),\n      ts.type(type(it.idlType)),\n      name_token(it.tokens.name, { data: it, parent }),\n      token(it.tokens.assign),\n      token(it.tokens.value),\n      token(it.tokens.termination)\n    ]), { data: it, parent });\n  }\n  function typedef(it) {\n    return ts.definition(ts.wrap([\n      extended_attributes(it.extAttrs),\n      token(it.tokens.base),\n      ts.type(type(it.idlType)),\n      name_token(it.tokens.name, { data: it }),\n      token(it.tokens.termination)\n    ]), { data: it });\n  }\n  function includes(it) {\n    return ts.definition(ts.wrap([\n      extended_attributes(it.extAttrs),\n      reference_token(it.tokens.target, it.target),\n      token(it.tokens.includes),\n      reference_token(it.tokens.mixin, it.includes),\n      token(it.tokens.termination)\n    ]), { data: it });\n  }\n  function callback(it) {\n    return ts.definition(ts.wrap([\n      extended_attributes(it.extAttrs),\n      token(it.tokens.base),\n      name_token(it.tokens.name, { data: it }),\n      token(it.tokens.assign),\n      ts.type(type(it.idlType)),\n      token(it.tokens.open),\n      ...it.arguments.map(argument),\n      token(it.tokens.close),\n      token(it.tokens.termination),\n    ]), { data: it });\n  }\n  function enum_(it) {\n    return ts.definition(ts.wrap([\n      extended_attributes(it.extAttrs),\n      token(it.tokens.base),\n      name_token(it.tokens.name, { data: it }),\n      token(it.tokens.open),\n      iterate(it.values, it),\n      token(it.tokens.close),\n      token(it.tokens.termination)\n    ]), { data: it });\n  }\n  function enum_value(v, parent) {\n    return ts.wrap([\n      ts.trivia(v.tokens.value.trivia),\n      ts.definition(wrap`\"${ts.name(v.value, { data: v, parent })}\"`, { data: v, parent }),\n      token(v.tokens.separator)\n    ]);\n  }\n  function iterable_like(it, parent) {\n    return ts.definition(ts.wrap([\n      extended_attributes(it.extAttrs),\n      token(it.tokens.readonly),\n      token(it.tokens.base),\n      token(it.tokens.open),\n      ts.wrap(it.idlType.map(type)),\n      token(it.tokens.close),\n      token(it.tokens.termination)\n    ]), { data: it, parent });\n  }\n  function eof(it) {\n    return ts.trivia(it.trivia);\n  }\n\n  const table = {\n    interface: container,\n    \"interface mixin\": container,\n    namespace: container,\n    operation,\n    attribute,\n    dictionary: container,\n    field,\n    const: const_,\n    typedef,\n    includes,\n    callback,\n    enum: enum_,\n    \"enum-value\": enum_value,\n    iterable: iterable_like,\n    legacyiterable: iterable_like,\n    maplike: iterable_like,\n    setlike: iterable_like,\n    \"callback interface\": container,\n    eof\n  };\n  function dispatch(it, parent) {\n    const dispatcher = table[it.type];\n    if (!dispatcher) {\n      throw new Error(`Type \"${it.type}\" is unsupported`);\n    }\n    return table[it.type](it, parent);\n  }\n  function iterate(things, parent) {\n    if (!things) return;\n    const results = things.map(thing => dispatch(thing, parent));\n    return ts.wrap(results);\n  }\n  return iterate(ast);\n}\n","\"use strict\";\r\n\r\nimport { validationError as error } from \"./error.js\";\r\n\r\nfunction groupDefinitions(all) {\r\n  const unique = new Map();\r\n  const duplicates = new Set();\r\n  const partials = new Map();\r\n  for (const def of all) {\r\n    if (def.partial) {\r\n      const array = partials.get(def.name);\r\n      if (array) {\r\n        array.push(def);\r\n      } else {\r\n        partials.set(def.name, [def]);\r\n      }\r\n      continue;\r\n    }\r\n    if (!def.name) {\r\n      continue;\r\n    }\r\n    if (!unique.has(def.name)) {\r\n      unique.set(def.name, def);\r\n    } else {\r\n      duplicates.add(def);\r\n    }\r\n  }\r\n  return { all, unique, partials, duplicates };\r\n}\r\n\r\nfunction* checkDuplicatedNames({ unique, duplicates }) {\r\n  for (const dup of duplicates) {\r\n    const { name } = dup;\r\n    const message = `The name \"${name}\" of type \"${unique.get(name).type}\" was already seen`;\r\n    yield error(dup.source, dup.tokens.name, dup, message);\r\n  }\r\n}\r\n\r\nfunction* checkInterfaceMemberDuplication(defs) {\r\n  const interfaces = [...defs.unique.values()].filter(def => def.type === \"interface\");\r\n  const includesMap = getIncludesMap();\r\n\r\n  for (const i of interfaces) {\r\n    yield* forEachInterface(i);\r\n  }\r\n\r\n  function* forEachInterface(i) {\r\n    const opNames = new Set(getOperations(i).map(op => op.name));\r\n    const partials = defs.partials.get(i.name) || [];\r\n    const mixins = includesMap.get(i.name) || [];\r\n    for (const ext of [...partials, ...mixins]) {\r\n      const additions = getOperations(ext);\r\n      yield* forEachExtension(additions, opNames, ext, i);\r\n      for (const addition of additions) {\r\n        opNames.add(addition.name);\r\n      }\r\n    }\r\n  }\r\n\r\n  function* forEachExtension(additions, existings, ext, base) {\r\n    for (const addition of additions) {\r\n      const { name } = addition;\r\n      if (name && existings.has(name)) {\r\n        const message = `The operation \"${name}\" has already been defined for the base interface \"${base.name}\" either in itself or in a mixin`;\r\n        yield error(ext.source, addition.body.tokens.name, ext, message);\r\n      }\r\n    }\r\n  }\r\n\r\n  function getOperations(i) {\r\n    return i.members\r\n      .filter(({type}) => type === \"operation\");\r\n  }\r\n\r\n  function getIncludesMap() {\r\n    const map = new Map();\r\n    const includes = defs.all.filter(def => def.type === \"includes\");\r\n    for (const include of includes) {\r\n      const array = map.get(include.target);\r\n      const mixin = defs.unique.get(include.includes);\r\n      if (!mixin) {\r\n        continue;\r\n      }\r\n      if (array) {\r\n        array.push(mixin);\r\n      } else {\r\n        map.set(include.target, [mixin]);\r\n      }\r\n    }\r\n    return map;\r\n  }\r\n}\r\n\r\nexport function validate(ast) {\r\n  const defs = groupDefinitions(ast);\r\n  return [\r\n    ...checkDuplicatedNames(defs),\r\n    ...checkInterfaceMemberDuplication(defs)\r\n  ];\r\n}\r\n","export { parse } from \"./lib/webidl2.js\";\r\nexport { write } from \"./lib/writer.js\";\r\nexport { validate } from \"./lib/validator.js\";\r\n"],"sourceRoot":""}